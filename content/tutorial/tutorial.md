---
id: tutorial
title: "Tutorial: Intro to Vue.js with TypeScript"
layout: tutorial
sectionid: tutorial
permalink: tutorial/tutorial.html
redirect_from:
  - "docs/tutorial.html"
---

This tutorial is a port of React's excellent tutorial to Vue.js and TypeScript.
This tutorial does not assume any existing Vue.js knowledge.

## Before We Start the Tutorial

We will build a small game during this tutorial. **You might be tempted to skip it because you're not building games -- but give it a chance.** The techniques you'll learn in the tutorial are fundamental to building any Vue.js apps, and mastering it will give you a deep understanding of Vue.js.

The tutorial is divided into several sections:

* [Setup for the Tutorial](#setup-for-the-tutorial) will give you **a starting point** to follow the tutorial.
* [Overview](#overview) will teach you **the fundamentals** of Vue.js: components, props, and state.
* [Completing the Game](#completing-the-game) will teach you **the most common techniques** in Vue.js development.
* [Adding Time Travel](#adding-time-travel) will give you **a deeper insight** into the unique strengths of Vue.js.

You don't have to complete all of the sections at once to get the value out of this tutorial. Try to get as far as you can -- even if it's one or two sections.

It's fine to copy and paste code as you're following along the tutorial, but we recommend to type it by hand. This will help you develop a muscle memory and a stronger understanding.

### What Are We Building?

In this tutorial, we'll show how to build an interactive tic-tac-toe game with Vue.js.

You can see what we'll be building here: **[Final Result](https://codepen.io/gaearon/pen/gWWZgR?editors=0010)**. Note that this version of the game has been built with React so the code you see there is not relevant for our purposes.

We recommend that you check out the tic-tac-toe game before continuing with the tutorial. One of the features that you'll notice is that there is a numbered list to the right of the game's board. This list gives you a history of all of the moves that have occurred in the game, and is updated as the game progresses.

You can close the tic-tac-toe game once you're familiar with it. We'll be starting from a simpler template in this tutorial. Our next step is to set you up so that you can start building the game.

### Prerequisites

We'll assume that you have some familiarity with HTML and JavaScript/TypeScript, but you should be able to follow along even if you're coming from a different programming language. We'll also assume that you're familiar with programming concepts like functions, objects, arrays, and to a lesser extent, classes.

If you need to review JavaScript, we recommend reading [this guide](https://developer.mozilla.org/en-US/docs/Web/JavaScript/A_re-introduction_to_JavaScript). Note that we're also using some features from ES6 -- a recent version of JavaScript. In this tutorial, we're using [arrow functions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions), [classes](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes), [`let`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let), and [`const`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/const) statements. You can use the [Babel REPL](babel://es5-syntax-example) to check what ES6 code compiles to.

We actually won't write any JavaScript but TypeScript which is essentially JavaScript with some added syntax. For a quick introduction you can check out [TypeScript in 5 minutes](https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes.html) which should give you a very basic idea.

## Setup for the Tutorial: Local Development Environment

1. Make sure you have a recent version of [Node.js](https://nodejs.org/en/) and [Yarn](https://yarnpkg.com) installed. You'll also need some text editor. At the time of this writing, [Visual Studio Code](https://code.visualstudio.com) seems to be the typescript editor of choice. Make sure to install TSLint, TSLint Vue, and the Vetur plugins for it. Finally, make sure you have the Vue plugin installed in your browser.
2. We'll setup an empty Vue.js/TypeScript project with `vue-cli`

```bash
yarn global add vue-cli
hash -r
mkdir my-app
cd my-app
vue init Toilal/vue-webpack-template
```

The defaults are mostly good, but we won't need the `vue-router`, we want to
externalize `<style>`, we want to use TypeScript, we don't need unit tests, no
`e2e` tests, and we want to use `Yarn` instead of `NPM`

After you answered all the questions it appears that you need to run `yarn` again to install required packages.

3. You can start your app by typing `yarn run dev`. Pointing your browser the URL it eventually displays, should produce a Welcome screen. Now you should open the `src/` directory in your editor. We won't need most of the autogenerated things, so you should delete the `assets/`, and the contents of `components/`.

4. Replace `App.css` with the following:

```css
body {
  font: 14px "Century Gothic", Futura, sans-serif;
  margin: 20px;
}

ol, ul {
  padding-left: 30px;
}

.board-row:after {
  clear: both;
  content: "";
  display: table;
}

.status {
  margin-bottom: 10px;
}

.square {
  background: #fff;
  border: 1px solid #999;
  float: left;
  font-size: 24px;
  font-weight: bold;
  line-height: 34px;
  height: 34px;
  margin-right: -1px;
  margin-top: -1px;
  padding: 0;
  text-align: center;
  width: 34px;
}

.square:focus {
  outline: none;
}

.kbd-navigation .square:focus {
  background: #ddd;
}

.game {
  display: flex;
  flex-direction: row;
}

.game-info {
  margin-left: 20px;
}
```

5. Replace `App.vue` with the following.

```
<template>
  <div id="app">
    <Game/>
  </div>
</template>
<script lang="ts">
import Vue from 'vue'
import Component from 'vue-class-component'

import Game from './components/Game.vue'

@Component({
  components: { Game }
})
export default class App extends Vue {

}
</script>

<style src="./App.css">
</style>
```

Now add `components/Game.vue`, `components/Board.vue`, `components/Square.vue` with the following contents:

```
<template>
  <div class="game">
    <div class="game-board">
      <Board />
    </div>
    <div class="game-info">
      <div><!-- status --></div>
      <ol><!-- TODO --></ol>
    </div>
  </div>
</template>
<script lang="ts">
import Vue from 'vue'
import Component from 'vue-class-component'

import Board from './Board.vue'

@Component({
  components: { Board }
})
export default class Game extends Vue {
}
</script>
```

```
<template>
  <div>
    <div class="status">Next player: X</div>
    <div class="board-row">
      <Square/>
      <Square/>
      <Square/>
    </div>
    <div class="board-row">
      <Square/>
      <Square/>
      <Square/>
    </div>
    <div class="board-row">
      <Square/>
      <Square/>
      <Square/>
    </div>
  </div>
</template>
<script lang="ts">
import Vue from 'vue'
import Component from 'vue-class-component'

import Square from './Square.vue'

@Component({
  components: { Square }
})
export default class Board extends Vue {
}
</script>
```

```
<template>
  <button class="square">
  </button>
</template>
<script lang="ts">
import Vue from 'vue'
import Component from 'vue-class-component'

@Component({})
export default class Square extends Vue {
}
</script>
```

6. Now if you open the URL you tried before in the browser you should see an empty tic-tac-toe field.

## Overview

Now that you're set up, let's get an overview of Vue.js!

### What Is Vue.js?

Vue.js is a declarative, efficient, and flexible JavaScript library for building user interfaces. It lets you compose complex UIs from small and isolated pieces of code called "components".

For our purposes, Vue.js components always corresponding to a `.vue` file that has two blocks, a `<template>` and a `<script>`.

```
<template>
  <div>
    <h1>Shopping List for {{name}}</h1>
    <ul>
      <li>Instagram</li>
      <li>WhatsApp</li>
      <li>Oculus</li>
    </ul>
  </div>
</template>
<script lang="ts">
import Vue from 'vue'
import Component from 'vue-class-component'
import Prop from 'vue-property-decorator'

@Component({})
export default class ShoppingList extends Vue {
  @Prop({}) name: string | null
}

// Example usage: <ShoppingList name="Mark" />
</script>
```

Here, ShoppingList is a **Vue.js component class**, or **Vue.js component type**. A component takes in parameters, called `props` (short for "properties"), and returns a hierarchy of views to display via its template.

A template contains just HTML but with some added magic. For example, you can put *any* JavaScript expressions within the double braces inside the template. Each Vue.js element is a JavaScript object that you can store in a variable or pass around in your program.

The `ShoppingList` component above only renders built-in DOM components like `<div />` and `<li />`. But you can compose and render custom Vue.js components too. For example, we can now refer to the whole shopping list by writing `<ShoppingList />`. Each Vue.js component is encapsulated and can operate independently; this allows you to build complex UIs from simple components.

Note that we have been using decorators in our TypeScript code. It's complicated (and probably boring) to know what these decorators do exactly. For the moment, you should just have noticed that we need `@Component({})` (which is the same as `@Component`) before every component.

## Inspecting the Starter Code

Please have a look at `App.vue` in your editor.

This Starter Code pulls in all the `.vue` files in the `components/` directory. It is the base of what we're building. We've provided the CSS styling so that you only need to focus on learning Vue.js and programming the tic-tac-toe game.

By inspecting the code, you'll notice that we have three Vue.js components:

* Square
* Board
* Game

The Square component renders a single `<button>` and the Board renders 9 squares. The Game component renders a board with placeholder values which we'll modify later. There are currently no interactive components.

### Passing Data Through Props

Just to get our feet wet, let's try passing some data from our Board component to our Square component.

In ``Board.vue``, change the template to pass a prop called ``value`` each Square:

```html
    <div class="board-row">
      <Square value="1"/>
      <Square value="2"/>
      <Square value="3"/>
    </div>
```

Change ``Square.vue`` so that it accepts a property called ``value`` (we add `@Prop` called `value`, and tell TypeScript that it's a `string` or `null` if it has not been set by the parent, i.e., the Board.)

```ts
import Vue from 'vue'
import Component from 'vue-class-component'

import { Prop } from 'vue-property-decorator'

@Component({})
export default class Square extends Vue {
  @Prop({}) value: string | null
}
```

Finally, we change the template so the value is actually rendered:

```html
  <button class="square">
    {{value}}
  </button>
```

You should now see numbers in all the squares that you assigned a `value` to in `Board.vue`.

**[View the full code at this point](https://codepen.io/gaearon/pen/aWWQOG?editors=0010)**

Congratulations! You've just "passed a prop" from a parent Board component to a child Square component. Passing props is how information flows in Vue.js apps, from parents to children.

### Making an Interactive Component

Let's fill the Square component with an "X" when we click it. Let's change our Square template again:

```html
  <button class="square" @click="value='X'">
    {{value}}
  </button>
```

We tell our Square to set `value` to `'X'` on each `click` event. Note that the `@` can equally be replaced with `v-on:`.

If we click on a Square now, it's value is replaced with an X.

Check that this works now. But when you look at the console in your browser's developer tools you should see that Vue.js is complaining about you mutating a prop. Exactly, a prop is supposed to only be set by the parent component and not mutated inside the child component.

### Private Compoent's State

To remove this warning, we just need to remove the `@Prop` marker from our prop. This tells Vue.js that this is now not being set from the outside but private state of a Square, only set and used by the Square internally.

```javascript
import Vue from 'vue'
import Component from 'vue-class-component'

// import { Prop } from 'vue-property-decorator'

@Component({})
export default class Square extends Vue {
  value: string | null = null
}
```

Now `value` is initially `null` until we click on it when it changes to an X.

### Developer Tools

This is probably a good moment to have a look at the Vue tab in your developer tools. Note that you can see the private state of all the components in your application.

## Completing the Game

We now have the basic building blocks for our tic-tac-toe game. To have a complete game, we now need to alternate placing "X"s and "O"s on the board, and we need a way to determine a winner.

### Lifting State Up

Currently, each Square component maintains the game's state. To check for a winner, we'll maintain the value of each of the 9 squares in one location.

We may think that Board should just ask each Square for the Square's state. Although this approach is possible in Vue.js, we discourage it because the code becomes difficult to understand, susceptible to bugs, and hard to refactor. Instead, the best approach is to store the game's state in the parent Board component instead of in each Square. The Board component can tell each Square what to display by passing a prop, [just like we did when we passed a number to each Square](#passing-data-through-props).

**To collect data from multiple children, or to have two child components communicate with each other, you need to declare the shared state in their parent component instead. The parent component can pass the state back down to the children by using props; this keeps the child components in sync with each other and with the parent component.**

Lifting state into a parent component is common when Vue.js components are refactored -- let's take this opportunity to try it out. We'll set the Board's initial state to contain an array with 9 nulls, corresponding to the 9 squares on the board:

```html
<template>
  <div>
    <div class="status">Next player: X</div>
    <div class="board-row">
      <Square :value="squares[0]"/>
      <Square :value="squares[1]"/>
      <Square :value="squares[2]"/>
    </div>
    <div class="board-row">
      <Square :value="squares[3]"/>
      <Square :value="squares[4]"/>
      <Square :value="squares[5]"/>
    </div>
    <div class="board-row">
      <Square :value="squares[6]"/>
      <Square :value="squares[7]"/>
      <Square :value="squares[8]"/>
    </div>
  </div>
</template>
<script lang="ts">
import Vue from 'vue'
import Component from 'vue-class-component'

import Square from './Square.vue'

@Component({
  components: { Square }
})
export default class Board extends Vue {
  squares: (string | null)[] = Array(9).fill(null)
}
</script>
```

When we fill the board in later, the board will look something like this:

```javascript
[
  'O', null, 'X',
  'X', 'X', 'O',
  'O', null, null,
]
```

Note that set the `value` of each `Square` to something like `squares[i]`. So we need to change `value` of each `Square` again to be a `@Prop` just like we had it earlier.

```html
<template>
  <button class="square">
    {{value}}
  </button>
</template>
<script lang="ts">
import Vue from 'vue'
import Component from 'vue-class-component'

import { Prop } from 'vue-property-decorator'

@Component({})
export default class Square extends Vue {
  @Prop({}) value: string | null = null
}
</script>
```

Note the syntax in `:value="squares[0]"`. The `:` is a shortcut for `v-bind:` and means that `squares[0]` should be evaluated to obtain the value. Without the colon the value would be set to the string "squares[0]" instead.

Each Square will now receive a `value` prop that will either be `'X'`, `'O'`, or `null` for empty squares (initially, all are empty.)

Next, we need to change what happens when a Square is clicked. The Board component now maintains which squares are filled. We need to create a way for the Square to update the Board's state. Since state is considered to be private to a component that defines it, we cannot update the Board's state directly from Square.

To maintain the Board's state's privacy, we'll pass down a function from the Board to the Square. This function will get called when a Square is clicked. We'll change our template in Board to:

```html
  …
  <Square :value="squares[0]" @click="handleClick(0)" />
  …
```

We also need to teach Board how to react to a click:

```javascript
export default class Board extends Vue {
  squares: (string | null)[] = Array(9).fill(null)

  handleClick (i: number) {
    this.squares = this.squares.slice()
    this.squares[i] = 'X'
  }
}
```

Note that we can not just write `this.squares[i] = 'X'` as one would usually do. The reason is that Vue can not detect such mutations, see https://vuejs.org/v2/guide/list.html#Caveats. Usually, one would write `Vue.set(this.squares, i, 'X')` here. But we want squares to be immutable, as we'll explain later.
Anayw, this does still not work as our Square does not emit a `click` event yet. We want to emit an event whenever the button inside the Square is clicked:

```html
<template>
  <button class="square" @click="$emit('click')">
    {{value}}
  </button>
</template>
```

Now, when a Square is clicked, the `handleClick` function provided by the Board is called. Here's a review of how this is achieved:

1. The `@click` prop on the built-in DOM `<button>` component tells Vue.js to set up a click event listener.
2. When the button is clicked, Vue.js will call the event handler `$emit('click')`.
3. This event handler triggers all event handlers that are subscribed to the Square's `click` event.
4. In particular this calls the Board's `handleClick` method.

After these changes, we're again able to click on the Squares to fill them. However, now the state is stored in the Board component instead of the individual Square components. When the Board's state changes, the Square components re-render automatically. Keeping the state of all squares in the Board component will allow it to determine the winner in the future.

Since the Square components no longer maintain state, the Square components receive values from the Board component and inform the Board component when they're clicked.

### Why Immutability Is Important

In the previous code example, we suggested that you use the `.slice()` operator to create a copy of the `squares` array to modify instead of modifying the existing array. We'll now discuss immutability and why immutability is important to learn.

There are generally two approaches to changing data. The first approach is to *mutate* the data by directly changing the data's values. The second approach is to replace the data with a new copy which has the desired changes.

#### Data Change with Mutation
```javascript
var player = {score: 1, name: 'Jeff'};
player.score = 2;
// Now player is {score: 2, name: 'Jeff'}
```

#### Data Change without Mutation
```javascript
var player = {score: 1, name: 'Jeff'};

var newPlayer = Object.assign({}, player, {score: 2});
// Now player is unchanged, but newPlayer is {score: 2, name: 'Jeff'}

// Or if you are using object spread syntax proposal, you can write:
// var newPlayer = {...player, score: 2};
```

The end result is the same but by not mutating (or changing the underlying data) directly, we gain several benefits described below.

#### Complex Features Become Simple

Immutability makes complex features much easier to implement. Later in this tutorial, we will implement a "time travel" feature that allows us to review the tic-tac-toe game's history and "jump back" to previous moves. This functionality isn't specific to games -- an ability to undo and redo certain actions is a common requirement in applications. Avoiding direct data mutation lets us keep previous versions of the game's history intact, and reuse them later.

#### Detecting Changes

Detecting changes in mutable objects is difficult because they are modified directly. This detection requires the mutable object to be compared to previous copies of itself and the entire object tree to be traversed.

Detecting changes in immutable objects is considerably easier. If the immutable object that is being referenced is different than the previous one, then the object has changed.

#### Determining When to Re-render in Vue.js 

The main benefit of immutability is that it helps you build _pure components_ in Vue.js. Immutable data can easily determine if changes have been made which helps to determine when a component requires re-rendering.

### Taking Turns

We now need to fix an obvious defect in our tic-tac-toe game: the "O"s cannot be marked on the board.

We'll set the first move to be "X" by default. We can set this default by modifying the initial state in our Board:

```javascript
export default class Board extends Vue {
  squares: (string | null)[] = Array(9).fill(null)
  xIsNext: boolean = true
  …
```

Each time a player moves, `xIsNext` (a boolean) will be flipped to determine which player goes next and the game's state will be saved. We'll update the Board's `handleClick` function to flip the value of `xIsNext`:

```javascript
  handleClick (i: number) {
    this.squares = this.squares.slice()
    this.squares[i] = this.xIsNext ? 'X' : 'O'
    this.xIsNext = !this.xIsNext
  }
```

With this change, "X"s and "O"s can take turns. Let's also change the "status" text in Board so that it displays which player has the next turn:

```html
  <div class="status">Next player: {{xIsNext ? 'X' : 'O'}}</div>
```

### Declaring a Winner

Now that we show which player's turn is next, we should also show when the game is won and there are no more turns to make. We can determine a winner by adding this helper function to the end of the file:

```javascript
  get winner () {
    const lines = [
      [0, 1, 2],
      [3, 4, 5],
      [6, 7, 8],
      [0, 3, 6],
      [1, 4, 7],
      [2, 5, 8],
      [0, 4, 8],
      [2, 4, 6]
    ]
    for (let i = 0; i < lines.length; i++) {
      const [a, b, c] = lines[i]
      if (this.squares[a] && this.squares[a] === this.squares[b] && this.squares[a] === this.squares[c]) {
        return this.squares[a]
      }
    }
    return null
  }
```

Note the `get` in front of our method. This makes `winner` a [computed property](https://vuejs.org/v2/guide/computed.html#Computed-vs-Watched-Property), i.e., this property is automatically recomputed whenever any of the state that was used to determine it changes.

Let's replace our status so that it shows the winner:

```html
    <div v-if="winner == null" class="status">Next player: {{xIsNext ? 'X' : 'O'}}</div>
    <div v-else class="status">Winner: {{winner}}</div>
```

Also, we should not allow not allow putting more markers on our board once a winner has been determined:

```javascript
  handleClick (i: number) {
    if (this.winner != null) {
      return
    }
    this.squares = this.squares.slice()
    this.squares[i] = this.xIsNext ? 'X' : 'O'
    this.xIsNext = !this.xIsNext
  }
```

Congratulations! You now have a working tic-tac-toe game. And you've just learned the basics of Vue.js too. So *you're* probably the real winner here.

## Adding Time Travel

As a final exercise, let's make it possible to "go back in time" to the previous moves in the game.

### Storing a History of Moves

If we mutated the `squares` array, implementing time travel would be very difficult.

However, we used `slice()` to create a new copy of the `squares` array after every move, and [treated it as immutable](#why-immutability-is-important). This will allow us to store every past version of the `squares` array, and navigate between the turns that have already happened.

We'll store the past `squares` arrays in another array called `history`. The `history` array represents all board states, from the first to the last move, and has a shape like this:

```javascript
history = [
  // Before first move
  {
    squares: [
      null, null, null,
      null, null, null,
      null, null, null,
    ]
  },
  // After first move
  {
    squares: [
      null, null, null,
      null, 'X', null,
      null, null, null,
    ]
  },
  // After second move
  {
    squares: [
      null, null, null,
      null, 'X', null,
      null, null, 'O',
    ]
  },
  // ...
]
```

Now we need to decide which component should own the `history` state.

### Lifting State Up, Again

We'll want the top-level Game component to display a list of past moves. It will need access to the `history` to do that, so we will place the `history` state in the top-level Game component.

Placing the `history` state into the Game component lets us remove the `squares` state from its child Board component. Just like we ["lifted state up"](#lifting-state-up) from the Square component into the Board component, we are now lifting it up from the Board into the top-level Game component. This gives the Game component full control over the Board's data, and lets it instruct the Board to render previous turns from the `history`.

First, we'll set up the initial state for the Game component:

```javascript
export default class Game extends Vue {
  history: (string | null)[][] = [Array(9).fill(null)]
}
```

Then we create a computed property `squares`, which is just the last entry in the history, and also turn `xIsNext` into a computed property:

```javascript
export default class Game extends Vue {
  history: (string | null)[][] = [Array(9).fill(null)]

  get squares (): (string | null)[] {
    return this.history[this.history.length - 1]
  }

  get xIsNext (): boolean {
    const xs = this.squares.filter(s => s === 'X').length
    const os = this.squares.filter(s => s === 'O').length
    return xs <= os
  }
}
```

We also pull up the `winner` property and create a dummy click handler:

```javascript
export default class Game extends Vue {
  history: (string | null)[][] = [Array(9).fill(null)]

  get squares (): (string | null)[] {
    return this.history[this.history.length - 1]
  }

  get xIsNext (): boolean {
    const xs = this.squares.filter(s => s === 'X').length
    const os = this.squares.filter(s => s === 'O').length
    return xs <= os
  }

  get winner () {
    const lines = [
      [0, 1, 2],
      [3, 4, 5],
      [6, 7, 8],
      [0, 3, 6],
      [1, 4, 7],
      [2, 5, 8],
      [0, 4, 8],
      [2, 4, 6]
    ]
    for (let i = 0; i < lines.length; i++) {
      const [a, b, c] = lines[i]
      if (this.squares[a] && this.squares[a] === this.squares[b] && this.squares[a] === this.squares[c]) {
        return this.squares[a]
      }
    }
    return null
  }

  handleClick (i: number) {
    console.log(`clicked ${i}`)
  }
}
```

Next, we'll have the Board component receive `squares` and `@click` props from the Game component. Since we now have a single click handler in Board for many Squares, we'll need to pass the location of each Square into the `@click` handler to indicate which Square was clicked. Here are the required steps to transform the Board component:

```html
<template>
  <div class="game">
    <div class="game-board">
      <Board :squares="squares" @click="handleClick" />
    </div>
    <div class="game-info">
      <div><!-- status --></div>
      <ol><!-- TODO --></ol>
    </div>
  </div>
</template>
```

Note that we write `handleClick` and not `handleClick()` so the parameters of the click event are passed into our `handleClick` method.

The Board component now looks like this:

```html
<template>
  <div>
    <div class="board-row">
      <Square :value="squares[0]" @click="$emit('click', 0)" />
      <Square :value="squares[1]" @click="$emit('click', 1)" />
      <Square :value="squares[2]" @click="$emit('click', 2)" />
    </div>
    <div class="board-row">
      <Square :value="squares[3]" @click="$emit('click', 3)" />
      <Square :value="squares[4]" @click="$emit('click', 4)" />
      <Square :value="squares[5]" @click="$emit('click', 5)" />
    </div>
    <div class="board-row">
      <Square :value="squares[6]" @click="$emit('click', 6)" />
      <Square :value="squares[7]" @click="$emit('click', 7)" />
      <Square :value="squares[8]" @click="$emit('click', 8)" />
    </div>
  </div>
</template>
<script lang="ts">
import Vue from 'vue'
import Component from 'vue-class-component'
import { Prop } from 'vue-property-decorator'

import Square from './Square.vue'

@Component({
  components: { Square }
})
export default class Board extends Vue {
  @Prop({}) squares: ('X' | 'O' | null)[]
}
</script>
```

We removed the Game status from the Board, so let's put this back into Game:

```html
<template>
  <div class="game">
    <div class="game-board">
      <Board :squares="squares" @click='handleClick' />
    </div>
    <div class="game-info">
      <div v-if="winner == null" class="status">Next player: {{xIsNext ? 'X' : 'O'}}</div>
      <div v-else class="status">Winner: {{winner}}</div>
    </div>
  </div>
</template>
```

We have not implemented `handleClick` yet. Note how clicking squares just displays some debug info on the console of your browser's developer tools. Let's implement it:

```javascript
  handleClick (i: number) {
    if (this.winner != null) {
      return
    }
    let squares = this.squares.slice()
    squares[i] = this.xIsNext ? 'X' : 'O'
    this.history.push(squares)
  }
```

Now the game should work again as it used to.

### Showing the Past Moves

Since we are recording the tic-tac-toe game's history, we can now display it to the player as a list of past moves.

We learned earlier that Vue.js elements are first-class JavaScript objects; we can pass them around in our applications. To render multiple items in Vue.js, we can use an array of Vue.js elements.

To render a list of things in a template, we can use `v-for`:

```html
<template>
  <div class="game">
    <div class="game-board">
      <Board :squares="squares" @click='handleClick' />
    </div>
    <div class="game-info">
      <div v-if="winner == null" class="status">Next player: {{xIsNext ? 'X' : 'O'}}</div>
      <div v-else class="status">Winner: {{winner}}</div>
      <ol>
          <li v-for="(squares, i) of history">
              <button @click="jumpTo(i)">Go to move {{i}}</button>
          </li>
      </ol>
    </div>
  </div>
</template>
```

Note that `(squares, i) of history` iterates over the items in history, assigning to `squares` the 9-element array and to `i` the index of the move.

For each move in the tic-tac-toes's game's history, we create a list item `<li>` which contains a button `<button>`. The button has a `@click` handler which calls a method called `jumpTo()`. We haven't implemented the `jumpTo()` method yet. For now, we should see a list of the moves that have occurred in the game and a warning in the developer tools console that says:

>  Elements in iteration expect to have 'v-bind:key' directives  

Let's discuss what the above warning means.

### Picking a Key

When we render a list, Vue.js stores some information about each rendered list item. When we update a list, Vue.js needs to determine what has changed. We could have added, removed, re-arranged, or updated the list's items.

Imagine transitioning from

```html
<li>Alexa: 7 tasks left</li>
<li>Ben: 5 tasks left</li>
```

to

```html
<li>Ben: 9 tasks left</li>
<li>Claudia: 8 tasks left</li>
<li>Alexa: 5 tasks left</li>
```

In addition to the updated counts, a human reading this would probably say that we swapped Alexa and Ben's ordering and inserted Claudia between Alexa and Ben. However, Vue.js is a computer program and does not know what we intended. Because Vue.js cannot know our intentions, we need to specify a *key* property for each list item to differentiate each list item from its siblings. One option would be to use the strings `alexa`, `ben`, `claudia`. If we were displaying data from a database, Alexa, Ben, and Claudia's database IDs could be used as keys.

```html
<li :key="user.id">{{user.name}}: {{user.taskCount}} tasks left</li>
```

`key` is a special and reserved property in Vue.js (along with `ref`, a more advanced feature). When an element is created, Vue.js extracts the `key` property and stores the key directly on the returned element. Even though `key` may look like it belongs in `props`, `key` cannot be referenced using `this.props.key`. Vue.js automatically uses `key` to decide which components to update. A component cannot inquire about its `key`.

When a list is re-rendered, Vue.js takes each list item's key and searches the previous list's items for a matching key. If the current list has a key that does not exist in the previous list, Vue.js creates a component. If the current list is missing a key that exists in the previous list, Vue.js destroys the previous component. If the keys match, the component is moved. Keys tell Vue.js about the identity of each component which allows Vue.js to maintain state between re-renders. If a component's key changes, the component will be destroyed and re-created with a new state.

**It's strongly recommended that you assign proper keys whenever you build dynamic lists.** If you don't have an appropriate key, you may want to consider restructuring your data so that you do.

If no key is specified, Vue.js will present a warning and use the array index as a key by default. Using the array index as a key is problematic when trying to re-order a list's items or inserting/removing list items. Explicitly passing `:key="i"` silences the warning but has the same problems as array indices and is not recommended in most cases.

Keys do not need to be globally unique. Keys only need to be unique between components and their siblings.


### Implementing Time Travel

In the tic-tac-toe game's history, each past move has a unique ID associated with it: it's the sequential number of the move. The moves are never re-ordered, deleted, or inserted in the middle, so it's safe to use the move index as a key.

In the Game component, we can add the key as `<li :key="i">` and Vue.js' warning about keys should disappear:

```html
<template>
  <div class="game">
    <div class="game-board">
      <Board :squares="squares" @click='handleClick' />
    </div>
    <div class="game-info">
      <div v-if="winner == null" class="status">Next player: {{xIsNext ? 'X' : 'O'}}</div>
      <div v-else class="status">Winner: {{winner}}</div>
      <ol>
          <li v-for="(squares, i) of history" :key="i">
              <button @click="jumpTo(i)">Go to move {{i}}</button>
          </li>
      </ol>
    </div>
  </div>
</template>
```

Clicking any of the list item's buttons throws an error because the `jumpTo` method is undefined. Before we implement `jumpTo`, we'll add `stepNumber` to the Game component's state to indicate which step we're currently viewing.

First, add `stepNumber: 0` to the initial state in Game:

```js
export default class Game extends Vue {
  history: (string | null)[][] = [Array(9).fill(null)]
  stepNumber: number = 0
  …
```

Next, we'll define the `jumpTo` method in Game to update that `stepNumber`. We also need to change `squares` to take the `stepNumber` into account (we also simplify `xIsNext` while we're at it:)

```javascript
  get squares (): (string | null)[] {
    return this.history[this.stepNumber]
  }

  get xIsNext (): boolean {
    return this.stepNumber % 2 === 0
  }

  jumpTo (i: number) {
    this.stepNumber = i
  }
```

We will now make a few changes to the Game's `handleClick` method which fires when you click on a square.

The `stepNumber` state we've added reflects the move displayed to the user now. After we make a new move, we need to update `stepNumber` by adding `stepNumber: history.length`. This ensures we don't get stuck showing the same move after a new one has been made.

We will also replace reading `this.history` with `this.history.slice(0, this.stepNumber + 1)`. This ensures that if we "go back in time" and then make a new move from that point, we throw away all the "future" history that would now become incorrect.

```javascript
  handleClick (i: number) {
    if (this.winner !== null) {
      return
    }
    let squares = this.squares.slice()
    squares[i] = this.xIsNext ? 'X' : 'O'
    this.history = this.history.slice(0, this.stepNumber + 1)
    this.history.push(squares)
    this.stepNumber++
  }
```

If we click on any step in the game's history, the tic-tac-toe board should immediately update to show what the board looked like after that step occurred.

### Wrapping Up

Congratulations! You've created a tic-tac-toe game that:

* Lets you play tic-tac-toe,
* Indicates when a player has won the game,
* Stores a game's history as a game progresses,
* Allows players to review a game's history and see previous versions of a game's board.

Nice work! We hope you now feel like you have a decent grasp on how Vue.js works.
